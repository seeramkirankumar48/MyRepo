Imp points::
------------
-->In java, a boolean data type value cannot hold the integer value it holds only true or false.
-->All the objects are stored in the Garbage-collectible heap. so if there are any unreferenced objects those are collected by the garbage collector.
-->if there are 100 classes it is not that easy to deliver all the classes to the client(since misses can happen) so it is quite easy if we package them into a .jar file and specify the manifest file where the main method is.
-->Arrays are always the objects whether they hold the primitive types or reference types.
-->length is just a parameter in the Array.It is a method in String class.
-->In java,we can save a file other than the className of that particular java file but it should not be decorated with public identifier
Ex1::
Sample.java is the file name where it contains two classes A,B
class A{
}
class B{
}
you can compile as javac Sample.java
but to know Class A,B you should run with java A || java B

Ex2::
consider a java file is saved with public identifier
you should run and compile with that public identified file.

var args::
----------
-->In java, a method can take variable number of arguments it is represented by three ellipses (...)
public static void main(String...args){
}

Java variables::
----------------
-->There are 3 types of variables in java::
1.local variables
2.instance variables
3.static variables

Difference between local variables and instance variables::
-----------------------------------------------------------
a.Local variables::
-----------------
These are declared inside the method.
Rule::
------
They should be initialized before usage.

b.instance variables::
--------------------
These are declared inside the class.
1.The instance variables can have the default values where as for the local variables they need to be initialized before the usage.
-->The instance variables are need not be intitialized even though without initialization they have the default values::
int - 0
float - 0.0
object(references) & string - null
boolean - false

--> There are 2 types of data types::
1.primitive
2.non-primitive(String,Array)

-->Java follows unicode format.

Operators::
------------
++,-- are called as unary operators.
ternary operator::
?:
int min=(a<b)?a:b;

Java loops::
------------
Infinite loops::
-->while(true)
-->Infinite for loop :: for(;;)
-->do{
    }while(true);
    
break and continue::
--------------------
-->The break statment will break out from the inner most loop and the continue statement is used to continue the loop skiping the current statement.


-------------------------
Disadvantages of Arrays::
-------------------------
1.Arrays cannot grow in size.
2.Arrays are used to store the homogenous types of data.
3.Arrays should always be used by the index.
4.we have to specify the size while creating the array.

we can create the array and initialize in same line using::
String[] arr={"kiran","kumar","seeram"};
or else in seperate lines using::
String[] arr;
arr=new String[]{"kiran","kumar","seeram"};
-------------------
Getters & setters::
-------------------
The getters & setters will not allow the instance variables to be exposed and they provide the validations to the fields before initialization it is a way of achieving encapsulation.
1.All the instance variables are declared private and the getters and setters are provided with public access.
Ex::
-----
public class MyClass {
    public static void main(String args[]) {
       Student stu=new Student();
       stu.setsid(100);
       System.out.println(stu.getSid());
    }
}
class Student{
    int sid;
    //getter
    public int getSid(){
        return this.sid;
    }
    //setter
    public void setsid(int id){
        this.sid=id;
    }
}

-----------------------------------------------------------

== Operator::
-------------
the "==" operator is used to check whether two variables values are same or not and it is also used to check whether two reference variables are pointing to the same object or not. In order to compare the objects itself use the equals() method.

-->The "Math" class is present in java.lang package. it also contains objects for Integer,Double,Float
-->The ArrayList class present in the java.util package.
-->the println statement(System.out.println()) is used from java.lang package under system class where out is the static variable of type PrintStream.
-->The java.lang package is pre-imported into the program by default so that's why when we write System.out.println or Integer we shouldn't import these packages as these are already imported from java.lang package.


Object::
--------
Each and every class implicitly extends the Object functionality::
it has 4 methods::
1.boolean equals()
2.Class getClass() //it is a final method hence cannot be overrided.
3.int hashCode()
4.String toString()

a.different ways to create the object::
-------------------------------------
By new keyword
By newInstance() method
By clone() method
By deserialization
By factory method etc.

b.ways to initialize object::
-----------------------------
1.By reference variable
s1.id=100;

2.By method
void insert(int i){
id=i;
}
Student s1=new Student();
s1.insert(100); //initialization using method "insert"

3.By constructor
Student s=new Student(100);

c.Anonymous objects::
---------------------
new Calculation().fact(5) //suitable only in the driver program only one instance is needed if there is more than one instance it will not be easy to call the object by reference variable.

d.Creating multiple objects by one type only::
----------------------------------------------
Rectangle r1=new Rectangle(), r2=new Rectangle();//creating two objects  
int a=10, b=20;  

Constructor::
-------------
Constructor is used to initialize the values to the objects.
Rules::
1.Constructor name must be same as className.
2.Constructor must not have explicit return type.
-->Even though if we didn't mention any constructor java implicitly provides the default constructor and provides the default values to the instance variables.but if we provide our own constructor then the default constructor doesn't exist.
There are 2 types of constructors.
1.Default constructor
2.parameterized constructor.

example that the default constructor initializes to default values::
class Student{
int sid;
String sname;
public void display(){
System.out.println(sid+" "+sname); // the default constructor intializes to zero and null and it will be done implicitly.
}
public static void main(String[] args){
Student s1=new Student();
s1.display();
}
}

we can copy the values of one object to the another object by any of the below methods::
1.By constructor
 Student6(Student6 s){  
    id = s.id;  
    name =s.name;  
    }  
    Student6 s1 = new Student6(111,"Karan");  
    Student6 s2 = new Student6(s1);
2.By assigning the values of one object into another through reference variables
 Student6 s1 = new Student6(111,"Karan");  
 Student6 s2 = new Student6();
 s2.id=s1.id;
 s2.name=s2.name;
3.By clone() method of Object class

-->Constructors returns the value::yes, that is current class instance (You cannot use return type yet it returns a value).


Static keyword::
----------------
-->The static keyword is mainly used for memory management in java.
the static can be applied to the ::
1.variable (also known as class variable)::
-->The static variable can be used to refer the common property of all objects (that is not unique for each object) e.g. company name of employees,college name of students etc.
-->The static variable gets memory only once in class area at the time of class loading.

??how it will save the memory::
suppose say a class:
class Student{
int sid;
String sname;
String college="ITU";
public Student(int sid,String sname){
this.sid=sid;
this.sname=sname;
}
}
public class Test{
public static void main(String[] args){
Student s1=new Student(1,"xxxxx");
Student s2=new Student(2,"yyyyy");
}
}
now, if we create 500 objects each object has the value college pointing to the string "ITU", now since this property is common to all the objects in the class so if we make it as static then there will be only one variable shared across to all the objects.

IMP::static gets memory at the time of class loading.

variables storage::
the object reference variables(s1,s2) are stored on stack, the objects (Student(1,"xxxxx"),Student(2,"yyyyy")) are stored on garbage collectible Heap, and the static variable is stored in the ClassArea.


2.method (also known as class method)::
-->A static method belongs to the class rather than object of a class.
-->A static method can be invoked without the need for creating an instance of a class.
-->static method can access only the static data member and can change the value of it.
-->Instance method can also change the value of the static member.
restrictions for static method::
-->The static method can not use non static data member or call non-static method directly.
-->this and super cannot be used in static context.

3.block::
-->Is used to initialize the static data member.
-->It is executed before main method at the time of classloading.
nested class

4.Nestedclass


this keyword::
--------------
1.this can be used to refer current class instance variable.
Student(int rollno,String name,float fee){  
rollno=rollno;  
name=name;  
fee=fee;  
}  
//here the parameter name and instance names are same so that's why it returns the o/p as:: 0 null 0.0
-->to distinguish from parameters with instance variables use::
Student(int rollno,String name,float fee){  
this.rollno=rollno;  
this.name=name;  
this.fee=fee;  
}  
-->if the parameter names and instance names are different then there is no need of this keyword
Student(int rollno,String name,float fee){  
Srollno=rollno;  
Sname=name;  
Sfee=fee;  
}

2.this can be used to invoke current class method (implicitly)

class A{  
void m(){System.out.println("hello m");}  
void n(){  
System.out.println("hello n");  
//m();//same as this.m()  
this.m();  
}  
}  
class TestThis4{  
public static void main(String args[]){  
A a=new A();  
a.n();  
}}  

3.this() can be used to invoke current class constructor.

class A{  
A(){System.out.println("hello a");}  
A(int x){  
this();  
System.out.println(x);  
}  
}  
class TestThis5{  
public static void main(String args[]){  
A a=new A(10);  
}}  

//the parameterized constructor is calling the default constructor.
-->The real use of the this() is used for constructor chaining.
class Student{  
int rollno;  
String name,course;  
float fee;  
Student(int rollno,String name,String course){  
this.rollno=rollno;  
this.name=name;  
this.course=course;  
}  
Student(int rollno,String name,String course,float fee){  
this(rollno,name,course);//reusing constructor  
this.fee=fee;  
}  
void display(){System.out.println(rollno+" "+name+" "+course+" "+fee);}  
}  
class TestThis7{  
public static void main(String args[]){  
Student s1=new Student(111,"ankit","java");  
Student s2=new Student(112,"sumit","java",6000f);  
s1.display();  
s2.display();  
}}   

Rule:: Call to this() must be the first statement in constructor.

4.this can be passed as an argument in the method call.
The this keyword can also be used as passing a parameter to the method.mainly, it is used in the event handling.
class S2{  
  void m(S2 obj){  
  System.out.println("method is invoked");  
  }  
  void p(){  
  m(this);  
  }  
  public static void main(String args[]){  
  S2 s1 = new S2();  
  s1.p();  
  }  
}  

5.this can be passed as argument in the constructor call.
We can pass the this keyword in the constructor also. It is useful if we have to use one object in multiple classes.
class B{  
  A4 obj;  
  B(A4 obj){  
    this.obj=obj;  
  }  
  void display(){  
    System.out.println(obj.data);//using data member of A4 class  
  }  
}  
  
class A4{  
  int data=10;  
  A4(){  
   B b=new B(this);  
   b.display();  
  }  
  public static void main(String args[]){  
   A4 a=new A4();  
  }  
}  


6.this can be used to return the current class instance from the method.
-->We can return this keyword as an statement from the method. In such case, return type of the method must be the class type.
class A{  
A getA(){  
return this;  
}  
void msg(){System.out.println("Hello java");}  
}  
class Test1{  
public static void main(String args[]){  
new A().getA().msg();  
}  
}  

-->To prove that this keyword always point to the current instance.

public class MyClass {
    public void m(){
        System.out.println(this);
    }
  public static void main(String[] args){
      MyClass c=new MyClass();
      System.out.println(c);
      c.m();
      
  }
}


ArrayLists::
------------
1.While creation of ArrayList we need not specify any size.

ArrayList<String> arr=new ArrayList<String>();
ArrayList can grow or sink in size.

2.unlike in array's we don't use [] to get the element.
3.ArrayList accepts only Reference types and wrapping or unwrapping is automatically done by the compiler itself.
ArrayList<Integer> arr=new ArrayList<Integer>();

-->In java it is always pass by value only.

Inheritance::
-------------
-->A base class is called superclass and the class which is inheriting that is called subclass.
-->A subclass can inherit all the methods and instance variables from the super class.
-->If a subclass has its own functionality then it can override the base class methods.(the instance variables of the super class are cannot be overridden).
-->In an inheritance structure "the lowest one wins".
Ex:Consider the inheritance structure::(Wolf->Canine->Animal)=>first it will check for the methods in the wolf if it is not there then it will check in the Canine or else it will call the method from Animal.
1.IS-A vs HAS-A relationship::
------------------------------
IS-A ex::(Surgeon extends Doctor) is a specialized component of Doctor.
HAS-A ex::classes (Tub,Sink) the Bathroom class has (Tub,Sink) i.e., the class Bathroom has components of both Tub and Sink.
class Bathroom{
Tub tub;
Sink sink;
}
-->To know if you've designed your types correctly, ask "Does it make sense to say type X is-a type Y".
-->Inheritance is an "IS-A" relationship.
-->Triangle is a shape but the reverse (shape is a Triangle is not true) so inheritance always allows in only one direction.
-->if X IS-A Y (x->y) then X can do all the things that Y can do.

2.common scenarios::
--------------------
a.what if the superclass wants to invoke the methods from subclass??
-->the parent class cannot know about any of the child classes,but during the creation of the child class it must know the which parent class it is inheriting.so , the parent class cannot inherit from child.

b.what if the subclass want to invoke bothe superclass version and its own version of the methods?? 
-->you can invoke the super class method by super.method()

-->The parent class may decide which fields or methods that a child class can inherit by providing the Access levels::
public,private,protected,default
-->we can override the parent class methods in the child class by mentioning the parameter called::@Override

Types of Inheritance::
---------------------
1.single
2.multiple
3.hierrarichal
4.multiple
5.hybrid

Polymorphism::
--------------
while creating the object, the object type and the reference type are same::
Dog myDog=new Dog();
but in polymorphims the object type and the reference type may not be same::
Animal myDog=new Dog();
so, in an inheritance relationship(IS-A), we can always reference the superclass type. 

Method overriding::
----------------------
-->If subclass provides the specific implementation that is same as super class then it is called as Method Overriding.
-->It is used to achieve runtime polymorphism.
Rules::
-------
1.The method which is going to override must contain the same signature,same arguments and same name as in the parent class.
2.the overrided method should not be less accessible.
3.must be in an IS-A relationship.

-->we cannot override static method because it is bound to the class where as the normal methods are bound to the instance level.so that means we cannot override the main method.It will be proved in runtime polymorphism.
-->So that,we cannot override the main method also, since it is also a static method.
public class MyClass {
    public static void main(String args[]) {
       Child p=new Child();
       p.fun();
    }
}
class Parent{
    public void fun(){
        System.out.println("Parent fun method");
    }
}
class Child extends Parent{
    protected void fun(){ //C.T error attempt to assing the weaker access previlages
        System.out.println("Child fun method");
    }
}

Java access modifiers with method overriding::
----------------------------------------------
If you are overriding any method, overridden method (i.e. declared in subclass) must not be more restrictive. else it will throw C.T error.

class A{  
protected void msg(){System.out.println("Hello java");}  
}  
  
public class Simple extends A{  
void msg(){System.out.println("Hello java");}//C.T.Error  
 public static void main(String args[]){  
   Simple obj=new Simple();  
   obj.msg();  
   }  
}  

The default modifier is more restrictive than protected. That is why there is compile time error.


Rules for Overloading::
-----------------------
-->Overloading is such that with same name we can define multiple functions:it improves the readability of the program.
there are 2 types in which method overloading is possible::
a.by changing number of arguments
b.by changing the data type

void Add(int a,int b)
void Add(int a,int b,int c)
//two methods with the same Name "Add" but with different number or type of arguments is called method overloading.


1.In java, method overloading is not possible by changing the return type of the method only because of ambiguity.

-->Method overloading is not possible by changing the return type of the method.
class Adder{  
static int add(int a,int b){return a+b;}  
static double add(int a,int b){return a+b;}  
}  
class TestOverloading3{  
public static void main(String[] args){  
System.out.println(Adder.add(11,11));//ambiguity  to call which add method
}}  

-->We can overload the main method in the java program.but the jvm will look for static main method with string[] arguments as parameter.

Type Promotions::
-----------------
int-->float,long,double
char-->int
byte-->short,int
short-->int
long-->float,double
float-->double

Example of method overloading with type promotion::

class OverloadingCalculation1{  
  void sum(int a,long b){System.out.println(a+b);}  
  void sum(int a,int b,int c){System.out.println(a+b+c);}  
  
  public static void main(String args[]){  
  OverloadingCalculation1 obj=new OverloadingCalculation1();  
  obj.sum(20,20);//now second int literal will be promoted to long  
  obj.sum(20,20,20);  
  
  }  
}  

-->If there are matching type arguments in the method, type promotion is not performed..
class OverloadingCalculation2{  
  void sum(int a,int b){System.out.println("int arg method invoked");}  
  void sum(long a,long b){System.out.println("long arg method invoked");}  
  
  public static void main(String args[]){  
  OverloadingCalculation2 obj=new OverloadingCalculation2();  
  obj.sum(20,20);//now int arg sum() method gets invoked  since they are matched with the the type of args.
  }  
}  

-->If there are no matching type arguments in the method, and each method promotes similar number of arguments, there will be ambiguity.
class OverloadingCalculation3{  
  void sum(int a,long b){System.out.println("a method invoked");}  
  void sum(long a,int b){System.out.println("b method invoked");}  
  
  public static void main(String args[]){  
  OverloadingCalculation3 obj=new OverloadingCalculation3();  
  obj.sum(20,20);//now ambiguity throws C.T error.
  }  
}  

Inheritance::
-------------
inheritance is used to achieve code reusability.
1.single.
2.multilevel
3.hierrarichal
4.multiple
multiple inheritance is such that there would two or more classes(super classes) and a subclass deriving from that super classes.
multiple inheritance is not supported in java.it is supported with interfaces.
ex::
class A{  
void msg(){System.out.println("Hello");}  
}  
class B{  
void msg(){System.out.println("Welcome");}  
}  
class C extends A,B{//suppose if it were  
   
 Public Static void main(String args[]){  
   C obj=new C();  
   obj.msg();//Now which msg() method would be invoked?  throws c.t error
}  
}  


Covariant Return Type::
----------------------
The covariant return type specifies that the return type may vary in the same direction as the subclass.

Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. Let's take a simple example:

class A{  
A get(){return this;}  
}  
  
class B1 extends A{  
B1 get(){return this;}  
void message(){System.out.println("welcome to covariant return type");}  
  
public static void main(String args[]){  
new B1().get().message();  
}  
}  

As you can see in the above example, the return type of the get() method of A class is A but the return type of the get() method of B class is B. Both methods have different return type but it is method overriding. This is known as covariant return type.

super keyword::
---------------
super keyword is used to refer the immediate parent class object.
Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred by super reference variable.
uses::
------
It is used to invoke parent class constructor,instance variables,parent class methods.
basically, it is used to differentiate the parent class instance variables or methods if they have the same name with the super class types.say suppose,
class Parent{
int i=10;
}
class Child{
int i=20;
public void display(){
System.out.println(i) //prints Child class i
System.out.println(super.i) // prints super class i
}
}

//if you want to call i it will print only child class i variable only if we want to call the parent class variables also then we have to go for super. similar is for methods.

1.super is used to refer immediate parent class instance variable::
class Animal{  
String color="white";  
}  
class Dog extends Animal{  
String color="black";  
void printColor(){  
System.out.println(color);//prints color of Dog class  
System.out.println(super.color);//prints color of Animal class  
}  
}  
class TestSuper1{  
public static void main(String args[]){  
Dog d=new Dog();  
d.printColor();  
}}

2.it is used to call the parent class method::
class Animal{  
void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
void eat(){System.out.println("eating bread...");}  
void bark(){System.out.println("barking...");}  
void work(){  
super.eat();  
bark();  
}  
}  
class TestSuper2{  
public static void main(String args[]){  
Dog d=new Dog();  
d.work();  
}}  

3.It is used to call the parent class constructor.
class Animal{  
Animal(){System.out.println("animal is created");}  
}  
class Dog extends Animal{  
Dog(){  
super();  
System.out.println("dog is created");  
}  
}  
class TestSuper3{  
public static void main(String args[]){  
Dog d=new Dog();  
}}  

Note::super() is added in each class constructor automatically by compiler if there is no super() or this().
      call to super must be first statement in constructor calling.

Example:: For super is implicitly provided by the compiler itself

class Animal{  
Animal(){System.out.println("animal is created");}  
}  
class Dog extends Animal{  
Dog(){  
System.out.println("dog is created");  
}  
}  
class TestSuper4{  
public static void main(String args[]){  
Dog d=new Dog();  
}}  

//prints ::
animal is created
dog is created

Instance Initializer block::
----------------------------
The Instance initializer block is used to initialize the instance members.

??what is the use of instance initializer block when we can initialize the members directly like::
class Bike{  
    int speed=100;  
}  

Suppose I have to perform some operations while assigning value to instance data member e.g. a for loop to fill a complex array or error handling etc.

??What is invoked first, instance initializer block or constructor?

class Bike8{  
    int speed;  
      
    Bike8(){System.out.println("constructor is invoked");}  
   
    {System.out.println("instance initializer block invoked");}   //instance initializer block
       
    public static void main(String args[]){  
    Bike8 b1=new Bike8();  
    Bike8 b2=new Bike8();  
    }      
}  

Output:instance initializer block invoked
       constructor is invoked
       instance initializer block invoked
       constructor is invoked
       
In the above example, it seems that instance initializer block is firstly invoked but NO. Instance intializer block is invoked at the time of object creation. The java compiler copies the instance initializer block in the constructor after the first statement super(). So firstly, constructor is invoked.

Rules::
-------
There are mainly three rules for the instance initializer block. They are as follows:
1.The instance initializer block is created when instance of the class is created.
2.The instance initializer block is invoked after the parent class constructor is invoked (i.e. after super() constructor call).
3.The instance initializer block comes in the order in which they appear.

Final Keyword::
---------------
the final keyword in java is used to restrict the user.
the final can be applied to the ::
1.Method
2.class
3.variable

variable::
once if it is initialized it cannot be changed.(not even in the constructor)
final String color="RED";

blank final variable::
---------------------
the final variables which are not initialized are called the blank final variables. they can be initialized only in the constructor and they cannot be modified anywhere.

final String color;
public Stu(){
color="RED";
}
similarly there are static final blank variables they can be initialized only in the static block and cannot be modified anywhere.

method::
once, if a method is declared as final it cannot be overriden.

class::
once if a class is declared as final we cannot inherit it.

Note::
Q: Can we declare a constructor final?
A: no,because constructor is never inherited.
Q: Is final method inherited?
A: Yes, final method is inherited but you cannot override it.
ex:
class Bike{  
  final void run(){System.out.println("running...");}  
}  
class Honda2 extends Bike{  
   public static void main(String args[]){  
    new Honda2().run();  
   }  
}  

Polymorphism::
--------------
Runtime polymorphism is decided at runtime.
-->runtime polymorphism is not acheived with the data members
package com.laboros.test;

public class Sample {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Animal a = new Dog();
		a.eat(); //prints the overrided method i.e Dog eat method
		System.out.println(a.i); //as data members are not overloaded prints the parent class i variable
	}

}

class Animal{
	int i=10;
	public void eat(){
		System.out.println("Animal eating");
	}
}

class Dog extends Animal{
	int i=20;
	public void eat(){
		System.out.println("Dog eating");
	}
}


Instance of::
-------------


Abstract::
----------
A class that is declared with abstract keyword, is known as abstract class in java. It can have abstract and non-abstract methods (method with body).

-->Abstraction is a process of hiding the implementation details and showing only functionality to the user

Rules::
-------
1.Abstract class may contain the abstract methods and normal methods
2.If a abstract class contains the abstract method then the class should be definetly mention the abstract keyword.
3. If you are extending any abstract class that have abstract method, you must either provide the implementation of the method or make this class abstract.
4.you cannot instantiate the abstract class.
5.An abstract class can have data member, abstract method, method body, constructor and even main() method.

program for 5th point::

abstract class Bike{  
  Bike(){System.out.println("bike is created");}  
  abstract void run();  
  void changeGear(){System.out.println("gear changed");}  
}  
 
class Honda extends Bike{  
void run(){System.out.println("running safely..");}  
 }  
 class TestAbstraction2{  
 public static void main(String args[]){  
  Bike obj = new Honda();  
  obj.run();  
  obj.changeGear();  
 }  
}  
  
interfaces::
------------
An interface in java is a blueprint of a class. It has static constants and abstract methods.
The interface in java is a mechanism to achieve abstraction. There can be only abstract methods in the java interface not method body. It is used to achieve abstraction and multiple inheritance in Java.
Since Java 8, interface can have default and static methods 

IMP::The java compiler adds public and abstract keywords before the interface method. More, it adds public, static and final keywords before data members.
In other words, Interface fields are public, static and final by default, and methods are public and abstract.

A class extends another class
A class implements interface
A interface extends another interface.

ex::
interface Bank{  
float rateOfInterest();  
}  
class SBI implements Bank{  
public float rateOfInterest(){return 9.15f;}  
}  
class PNB implements Bank{  
public float rateOfInterest(){return 9.7f;}  
}  
class TestInterface2{  
public static void main(String[] args){  
Bank b=new SBI();  
System.out.println("ROI: "+b.rateOfInterest());  
}}  

//ROI: 9.15

multiple inheritance::
----------------------

interface Printable{  
void print();  
}  
interface Showable{  
void show();  
}  
class A7 implements Printable,Showable{  
public void print(){System.out.println("Hello");}  
public void show(){System.out.println("Welcome");}  
  
public static void main(String args[]){  
A7 obj = new A7();  
obj.print();  
obj.show();  
 }  
}  

Hello
Welcome

As implementation is provided by the implementation class hence there will be no ambiguity hence, multiple inheritance is possible with interfaces.

Since Java 8, we can have method body in interface. But we need to make it default method. 
the reason why the default method is provided is because, consider an interface in which it contains the method declarations for 5 methods and that particular interface is extended by 10 classes.say if tomorrow, if you need to add the method declaration for one more method in the interface you need to extend that functionality to all other subclasses which are inheriting from that particular interface so in order to provide the backward compatibility the default methods are provided.

interface Drawable{  
void draw();  
default void msg(){System.out.println("default method");}  
}  
class Rectangle implements Drawable{  
public void draw(){System.out.println("drawing rectangle");}  
}  
class TestInterfaceDefault{  
public static void main(String args[]){  
Drawable d=new Rectangle();  
d.draw();  
d.msg();  
}}  

what if in multiple inheritance if 2 interfaces provide the same default method so you have to override that particular method in the implementation class.

interface IA{
    default public void show(){
        System.out.println("show method IA");
    }
}
interface IB{
    default public void show(){
        System.out.println("show method IB");
    }
}
class A implements IA,IB{
    public void show(){
        IA.super.show();
    }
}
public class MyClass {
    public static void main(String args[]) {
      A a=new A();
       a.show();
    }
}

so what is the difference b/w abstract and interfaces if it is also providing the implemenations.
1.Abstract class can have a constructor.
2.Abstract classes are more structured and can hold a state.

Since Java 8, we can have static method in interface. Let's see an example:

interface Drawable{  
void draw();  
static int cube(int x){return x*x*x;}  
}  
class Rectangle implements Drawable{  
public void draw(){System.out.println("drawing rectangle");}  
}  
  
class TestInterfaceStatic{  
public static void main(String args[]){  
Drawable d=new Rectangle();  
d.draw();  
System.out.println(Drawable.cube(3));  
}}  

Tagged Interface::
------------------
An interface that have no member is known as marker or tagged interface. For example: Serializable, Cloneable, Remote etc. They are used to provide some essential information to the JVM so that JVM may perform some useful operation.

public interface Serializable{  
}  

Nested Interface::
------------------
interface within an another interface.

interface printable{  
 void print();  
 interface MessagePrintable{  
   void msg();  
 }  
}  

Package::
---------
A java package is a group of similar types of classes, interfaces and sub-packages.
Advantage of Java Package

1) Java package is used to categorize the classes and interfaces so that they can be easily maintained.

2) Java package provides access protection.

3) Java package removes naming collision.
e.g. java.util and java.sql packages contain Date class.

Note: If you import a package, subpackages will not be imported.
The standard of defining package is domain.company.package e.g. com.javatpoint.bean or org.sssit.dao.

ex::
package com.javatpoint.core;  
class Simple{  
  public static void main(String args[]){  
   System.out.println("Hello subpackage");  
  }  
}  
ToRun::
-------
To Compile: javac -d . Simple.java
To Run: java com.javatpoint.core.Simple

to store the class file in differnt directory::
javac -d c:\classes\Simple.java
to execute::
set classpath=c:\classes;
java mpack.Simple
 (or) 
java -classpath c:\classes mypack.Simple

Package class

The package class provides methods to get information about the specification and implementation of a package. It provides methods such as getName(), getImplementationTitle(), getImplementationVendor(), getImplementationVersion() etc.

ex::
class PackageInfo{  
public static void main(String args[]){  
   
Package p=Package.getPackage("java.lang");  
  
System.out.println("package name: "+p.getName());  
  
System.out.println("Specification Title: "+p.getSpecificationTitle());  
System.out.println("Specification Vendor: "+p.getSpecificationVendor());  
System.out.println("Specification Version: "+p.getSpecificationVersion());  
  
System.out.println("Implementaion Title: "+p.getImplementationTitle());  
System.out.println("Implementation Vendor: "+p.getImplementationVendor());  
System.out.println("Implementation Version: "+p.getImplementationVersion());  
System.out.println("Is sealed: "+p.isSealed());  
  
  
 }  
}  

o/p::
-----
package name: java.lang
       Specification Title: Java Plateform API Specification
       Specification Vendor: Sun Microsystems, Inc.
       Specification Version: 1.6
       Implemenation Title: Java Runtime Environment
       Implemenation Vendor: Sun Microsystems, Inc.
       Implemenation Version: 1.6.0_30
       IS sealed: false
       
      
AccessModifiers::
----------------
The access modifiers in java specifies accessibility (scope) of a data member, method, constructor or class.
There are 4 types of java access modifiers:
There are many non-access modifiers such as static, abstract, synchronized, native, volatile, transient etc

a.private
The private access modifier is accessible only within class.
ex1::
class A{  
private int data=40;  
private void msg(){System.out.println("Hello java");}  
}  
  
public class Simple{  
 public static void main(String args[]){  
   A obj=new A();  
   System.out.println(obj.data);//Compile Time Error  
   obj.msg();//Compile Time Error  
   }  
}  
ex2::
class A{  
private A(){}//private constructor  
void msg(){System.out.println("Hello java");}  
}  
public class Simple{  
 public static void main(String args[]){  
   A obj=new A();//Compile Time Error  
 }  
}  

Note: A class cannot be private or protected except nested class.

b.default
If you don't use any modifier, it is treated as default bydefault. The default modifier is accessible only within package.

//save by A.java  
package pack;  
class A{  
  void msg(){System.out.println("Hello");}  
}

//save by B.java  
package mypack;  
import pack.*;  
class B{  
  public static void main(String args[]){  
   A obj = new A();//Compile Time Error  
   obj.msg();//Compile Time Error  
  }  
}
In the above example, the scope of class A and its method msg() is default so it cannot be accessed from outside the package.

c.protected
The protected access modifier is accessible within package and outside the package but through inheritance only.
The protected access modifier can be applied on the data member, method and constructor. It can't be applied on the class.

//save by A.java  
package pack;  
public class A{  
protected void msg(){System.out.println("Hello");}  
}  

//save by B.java  
package mypack;  
import pack.*;  
  
class B extends A{   //through inheritance it is accessible
  public static void main(String args[]){  
   B obj = new B();  
   obj.msg();  
  }  
}  

o/p::Hello

d.public
it 's accessible anywhere.

Array::
-------
Syntax to Declare an Array in java
dataType[] arr; (or)  
dataType []arr; (or)  
dataType arr[]; 

length is the property of array  

int a[]=new int[5];//declaration and instantiation  
a[0]=10;//initialization  
a[1]=20;  
a[2]=70;  
a[3]=40;  
a[4]=50;  

int a[]={33,3,4,5};//declaration, instantiation and initialization 

Passing array as a parameter to the method::

class Testarray2{  
static void min(int arr[]){  
int min=arr[0];  
for(int i=1;i<arr.length;i++)  
 if(min>arr[i])  
  min=arr[i];  
  
System.out.println(min);  
}  
  
public static void main(String args[]){  
  
int a[]={33,3,4,5};  
min(a);//passing array to method  
  
}}  

Multidimensional Array:
-----------------------
dataType[][] arrayRefVar; (or)  
dataType [][]arrayRefVar; (or)  
dataType arrayRefVar[][]; (or)  
dataType []arrayRefVar[];   

int[][] arr=new int[3][3];//3 row and 3 column

//declaring and initializing 2D array  
int arr[][]={{1,2,3},{2,4,5},{4,4,5}};  

for(int i=0;i<3;i++){  
 for(int j=0;j<3;j++){  
   System.out.print(arr[i][j]+" ");  
 }  
 System.out.println();  
}  

Copying a java array

We can copy an array to another by the arraycopy method of System class.

Syntax of arraycopy method

public static void arraycopy(  
Object src, int srcPos,Object dest, int destPos, int length  
)  

Object cloning::
----------------



//225

ToCheck::
---------
1.what are the contents inside the jdk and jre folders.
2.program to check::
import java.util.*;
public class MyClass {
    static int n1=0,n2=1,n3=1;
    public static void main(String args[]) {
      System.out.println("Enter the fibo number:");
      Scanner scr=new Scanner(System.in);
      int number=scr.nextInt();
      System.out.println(n1+"\n"+n2);
      fibo(number-2);
    }
    public static void fibo(int count){
        while(count>0){
            System.out.println("Iteration number:"+count);
            n3=n1+n2;
            System.out.println(n3);
            n1=n2;
            n2=n3;
           fibo(count-1);
        }
    }
}
3.methods with same signature but differentiated with static and normal methods.
4.constructor chaining.
5.what is default method?
6.why the protected access modifier is not applied to the class?

