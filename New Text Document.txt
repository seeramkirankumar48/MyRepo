Imp points::
------------
-->In java, a boolean value cannot hold the integer value it holds only true or false.
-->All the objects are stored in the Garbage-collectible heap. so if there are any unreferenced objects those are collected by the garbage collector.
-->if there are 100 classes it is not that easy to deliver all the classes to the client(since misses can happen) so it is quite easy if we package them into a .jar file and specify the manifest file where the main method is.
-->Arrays are always the objects whether they hold the primitive types or reference types.
-->length is just a parameter in the Array.
-->In java,we can save a file other than the className of that particular java file but it should not be decorated with public identifier
Ex1::
Sample.java is the file name where it contains two classes A,B
class A{
}
class B{
}
you can compile as javac Sample.java
but to know Class A,B you should run with java A || java B

Ex2::
consider a java file is saved with public identifier
you should run and compile with that public identified file.

var args::
----------
-->In java, a method can take variable number of arguments it is represented by three ellipses (...)
public static void main(String...args){
}

Java variables::
----------------
-->There are 3 types of variables in java::
1.local variables
2.instance variables
3.static variables

--> There are 2 types of data types::
1.primitive
2.non-primitive(String,Array)

-->Java follows unicode format.

Operators::
------------
++,-- are called as unary operators.
ternary operator::
?:
int min=(a<b)?a:b;

Java loops::
------------
Infinite loops::
-->while(true)
-->Infinite for loop :: for(;;)
-->do{
    }while(true);
    
break and continue::
--------------------
-->The break statment will break out from the inner most loop and the continue statement is used to continue the loop skiping the current statement.


-------------------------
Disadvantages of Arrays::
-------------------------
1.Arrays cannot grow in size.
2.Arrays are used to store the homogenous types of data.
3.Arrays should always be used by the index.
4.we have to specify the size while creating the array.

we can create the array and initialize in same line using::
String[] arr={"kiran","kumar","seeram"};
or else in seperate lines using::
String[] arr;
arr=new String[]{"kiran","kumar","seeram"};
-------------------
Getters & setters::
-------------------
The getters & setters will not allow the instance variables to be exposed and they provide the validations to the fields before initialization it is a way of achieving encapsulation.
1.All the instance variables are declared private and the getters and setters are provided with public access.
Ex::
-----
public class MyClass {
    public static void main(String args[]) {
       Student stu=new Student();
       stu.setsid(100);
       System.out.println(stu.getSid());
    }
}
class Student{
    int sid;
    //getter
    public int getSid(){
        return this.sid;
    }
    //setter
    public void setsid(int id){
        this.sid=id;
    }
}
-->The instance variables are need not be intitialized even though without initialization they have the default values::
int - 0
float - 0.0
object(references) & string - null
boolean - false
-----------------------------------------------------------
Difference between local variables and instance variables::
-----------------------------------------------------------
Local variables::
-----------------
These are declared inside the method.
instance variables::
--------------------
These are declared inside the class.
1.The instance variables can have the default values where as for the local variables they need to be initialized before the usage.
== Operator::
-------------
the "==" operator is used to check whether two variables values are same or not and it is also used to check whether two reference variables are pointing to the same object or not. In order to compare the objects itself use the equals() method.

-->The "Math" class is present in java.lang package. it also contains objects for Integer,Double,Float
-->The ArrayList class present in the java.util package.
-->the println statement(System.out.println()) is used from java.lang package under system class.
-->The java.lang package is pre-imported into the program by default so that's why when we write System.out.println or Integer we shouldn't import these packages as these are already imported from java.lang package.

ArrayLists::
------------
1.While creation of ArrayList we need not specify any size.

ArrayList<String> arr=new ArrayList<String>();
ArrayList can grow or sink in size.

2.unlike in array's we don't use [] to get the element.
3.ArrayList accepts only Reference types and wrapping or unwrapping is automatically done by the compiler itself.
ArrayList<Integer> arr=new ArrayList<Integer>();

-->In java it is always pass by value only.

Inheritance::
-------------
-->A base class is called superclass and the class which is inheriting that is called subclass.
-->A subclass can inherit all the methods and instance variables from the super class.
-->If a subclass has its own functionality then it can override the base class methods.(the instance variables of the super class are cannot be overridden).
-->In an inheritance structure "the lowest one wins".
Ex:Consider the inheritance structure::(Wolf->Canine->Animal)=>first it will check for the methods in the wolf if it is not there then it will check in the Canine or else it will call the method from Animal.
1.IS-A vs HAS-A relationship::
------------------------------
IS-A ex::(Surgeon extends Doctor) is a specialized component of Doctor.
HAS-A ex::classes (Tub,Sink) the Bathroom class has (Tub,Sink) i.e., the class Bathroom has components of both Tub and Sink.
class Bathroom{
Tub tub;
Sink sink;
}
-->To know if you've designed your types correctly, ask "Does it make sense to say type X is-a type Y".
-->Inheritance is an "IS-A" relationship.
-->Triangle is a shape but the reverse (shape is a Triangle is not true) so inheritance always allows in only one direction.
-->if X IS-A Y (x->y) then X can do all the things that Y can do.

2.common scenarios::
--------------------
a.what if the superclass wants to invoke the methods from subclass??
-->the parent class cannot know about any of the child classes,but during the creation of the child class it must know the which parent class it is inheriting.so , the parent class cannot inherit from child.

b.what if the subclass want to invoke bothe superclass version and its own version of the methods?? 
-->you can invoke the super class method by super.method()

-->The parent class may decide which fields or methods that a child class can inherit by providing the Access levels::
public,private,protected,default
-->we can override the parent class methods in the child class by mentioning the parameter called::@Override

Polymorphism::
--------------
while creating the object, the object type and the reference type are same::
Dog myDog=new Dog();
but in polymorphims the object type and the reference type may not be same::
Animal myDog=new Dog();
so, in an inheritance relationship(IS-A), we can always reference the superclass type. 

Method overriding::
----------------------
-->It is used to achieve runtime polymorphism.
Rules::
-------
1.The method which is going to override must contain the same signature,same arguments and same name.
2.the overrided method should not be less accessible.
3.must be in an IS-A relationship.

-->we cannot override static method because it is bound to the class where as the normal methods are bound to the instance level.so that means we cannot override the main method.
public class MyClass {
    public static void main(String args[]) {
       Child p=new Child();
       p.fun();
    }
}
class Parent{
    public void fun(){
        System.out.println("Parent fun method");
    }
}
class Child extends Parent{
    protected void fun(){ //C.T error attempt to assing the weaker access previlages
        System.out.println("Child fun method");
    }
}



Rules for Overloading::
-----------------------
-->Overloading is such that with same name we can define multiple functions:it improves the readability of the program.
1.In java, method overloading is not possible by changing the return type of the method only because of ambiguity.

-->Method overloading is not possible by changing the return type of the method.
class Adder{  
static int add(int a,int b){return a+b;}  
static double add(int a,int b){return a+b;}  
}  
class TestOverloading3{  
public static void main(String[] args){  
System.out.println(Adder.add(11,11));//ambiguity  to call which add method
}}  

-->We can overload the main method in the java program.but the jvm will look for static main method with string[] args parameter.

Type Promotions::
-----------------
int-->float,long,double
char-->int
byte-->short,int
short-->int
long-->float,double
float-->double

Example of method overloading with type promotion::

class OverloadingCalculation1{  
  void sum(int a,long b){System.out.println(a+b);}  
  void sum(int a,int b,int c){System.out.println(a+b+c);}  
  
  public static void main(String args[]){  
  OverloadingCalculation1 obj=new OverloadingCalculation1();  
  obj.sum(20,20);//now second int literal will be promoted to long  
  obj.sum(20,20,20);  
  
  }  
}  

-->If there are matching type arguments in the method, type promotion is not performed..
class OverloadingCalculation2{  
  void sum(int a,int b){System.out.println("int arg method invoked");}  
  void sum(long a,long b){System.out.println("long arg method invoked");}  
  
  public static void main(String args[]){  
  OverloadingCalculation2 obj=new OverloadingCalculation2();  
  obj.sum(20,20);//now int arg sum() method gets invoked  
  }  
}  

-->If there are no matching type arguments in the method, and each method promotes similar number of arguments, there will be ambiguity.
class OverloadingCalculation3{  
  void sum(int a,long b){System.out.println("a method invoked");}  
  void sum(long a,int b){System.out.println("b method invoked");}  
  
  public static void main(String args[]){  
  OverloadingCalculation3 obj=new OverloadingCalculation3();  
  obj.sum(20,20);//now ambiguity  
  }  
}  



Object::
--------
Each and every class implicitly extends the Object functionality::
it has 4 methods::
1.boolean equals()
2.Class getClass() //it is a final method hence cannot be overrided.
3.int hashCode()
4.String toString()

a.different ways to create the object::
-------------------------------------
By new keyword
By newInstance() method
By clone() method
By deserialization
By factory method etc.

b.ways to initialize object::
-----------------------------
1.By reference variable
s1.id=100;

2.By method
void insert(int i){
id=i;
}
Student s1=new Student();
s1.insert(100); //initialization using method "insert"

3.By constructor
Student s=new Student(100);

c.Anonymous objects::
---------------------
new Calculation().fact(5) //suitable only in the driver program only one instance is needed if there is more than one instance it will not be easy to call the object by reference variable.

d.Creating multiple objects by one type only::
----------------------------------------------
Rectangle r1=new Rectangle(), r2=new Rectangle();//creating two objects  
int a=10, b=20;  

Constructor::
-------------
Constructor is used to initialize the values to the objects.
Rules::
1.Constructor name must be same as className.
2.Constructor must not have explicit return type.
-->Even though if we didn't mention any constructor java implicitly provides the default constructor and provides the default values to the instance variables.but if we provide our own constructor then the default constructor doesn't exist.
There are 2 types of constructors.
1.Default constructor
2.parameterized constructor.

example that the default constructor initializes to default values::
class Student{
int sid;
String sname;
public void display(){
System.out.println(sid+" "+sname); // the default constructor intializes to zero and null and it will be done implicitly.
}
public static void main(String[] args){
Student s1=new Student();
s1.display();
}
}

we can copy the values of one object to the another object by any of the below methods::
1.By constructor
 Student6(Student6 s){  
    id = s.id;  
    name =s.name;  
    }  
    Student6 s1 = new Student6(111,"Karan");  
    Student6 s2 = new Student6(s1);
2.By assigning the values of one object into another through reference variables
 Student6 s1 = new Student6(111,"Karan");  
 Student6 s2 = new Student6();
 s2.id=s1.id;
 s2.name=s2.name;
3.By clone() method of Object class

-->Constructors returns the value::yes, that is current class instance (You cannot use return type yet it returns a value).

Infinitive Loops::
------------------
while(true)
for(;;)

-->we can save the java class file with other than class name by removing the public access modifier and running the java program with that classname.

Static keyword::
----------------
-->The static keyword is mainly used for memory management in java.
the static can be applied to the ::
variable (also known as class variable)::
-->The static variable can be used to refer the common property of all objects (that is not unique for each object) e.g. company name of employees,college name of students etc.
-->The static variable gets memory only once in class area at the time of class loading.

method (also known as class method)::
-->A static method belongs to the class rather than object of a class.
-->A static method can be invoked without the need for creating an instance of a class.
-->static method can access static data member and can change the value of it.
restrictions for static method::
-->The static method can not use non static data member or call non-static method directly.
-->this and super cannot be used in static context.

block::
-->Is used to initialize the static data member.
-->It is executed before main method at the time of classloading.
nested class

this keyword::
--------------
1.this can be used to refer current class instance variable.
Student(int rollno,String name,float fee){  
rollno=rollno;  
name=name;  
fee=fee;  
}  
//here the parameter name and instance names are same so that's why it returns the o/p as:: 0 null 0.0
-->to distinguish from parameters with instance variables use::
Student(int rollno,String name,float fee){  
this.rollno=rollno;  
this.name=name;  
this.fee=fee;  
}  
-->if the parameter names and instance names are different then there is no need of this keyword
Student(int rollno,String name,float fee){  
Srollno=rollno;  
Sname=name;  
Sfee=fee;  
}

2.this can be used to invoke current class method (implicitly)

class A{  
void m(){System.out.println("hello m");}  
void n(){  
System.out.println("hello n");  
//m();//same as this.m()  
this.m();  
}  
}  
class TestThis4{  
public static void main(String args[]){  
A a=new A();  
a.n();  
}}  

3.this() can be used to invoke current class constructor.

class A{  
A(){System.out.println("hello a");}  
A(int x){  
this();  
System.out.println(x);  
}  
}  
class TestThis5{  
public static void main(String args[]){  
A a=new A(10);  
}}  

//the parameterized constructor is calling the default constructor.
-->The real use of the this() is used for constructor chaining.
class Student{  
int rollno;  
String name,course;  
float fee;  
Student(int rollno,String name,String course){  
this.rollno=rollno;  
this.name=name;  
this.course=course;  
}  
Student(int rollno,String name,String course,float fee){  
this(rollno,name,course);//reusing constructor  
this.fee=fee;  
}  
void display(){System.out.println(rollno+" "+name+" "+course+" "+fee);}  
}  
class TestThis7{  
public static void main(String args[]){  
Student s1=new Student(111,"ankit","java");  
Student s2=new Student(112,"sumit","java",6000f);  
s1.display();  
s2.display();  
}}   

Rule:: Call to this() must be the first statement in constructor.

4.this can be passed as an argument in the method call.
The this keyword can also be used as passing a parameter to the method.mainly, it is used in the event handling.
class S2{  
  void m(S2 obj){  
  System.out.println("method is invoked");  
  }  
  void p(){  
  m(this);  
  }  
  public static void main(String args[]){  
  S2 s1 = new S2();  
  s1.p();  
  }  
}  

5.this can be passed as argument in the constructor call.
We can pass the this keyword in the constructor also. It is useful if we have to use one object in multiple classes.
class B{  
  A4 obj;  
  B(A4 obj){  
    this.obj=obj;  
  }  
  void display(){  
    System.out.println(obj.data);//using data member of A4 class  
  }  
}  
  
class A4{  
  int data=10;  
  A4(){  
   B b=new B(this);  
   b.display();  
  }  
  public static void main(String args[]){  
   A4 a=new A4();  
  }  
}  


6.this can be used to return the current class instance from the method.
-->We can return this keyword as an statement from the method. In such case, return type of the method must be the class type.
class A{  
A getA(){  
return this;  
}  
void msg(){System.out.println("Hello java");}  
}  
class Test1{  
public static void main(String args[]){  
new A().getA().msg();  
}  
}  

-->To prove that this keyword always point to the current instance.

public class MyClass {
    public void m(){
        System.out.println(this);
    }
  public static void main(String[] args){
      MyClass c=new MyClass();
      System.out.println(c);
      c.m();
      
  }
}

Inheritance::
-------------
inheritance is used to achieve code reusability.
1.single.
2.multilevel
3.hierrarichal
4.multiple
multiple inheritance is such that there would two or more classes(super classes) and a subclass deriving from that super classes.
multiple inheritance is not supported in java.it is supported with interfaces.
ex::
class A{  
void msg(){System.out.println("Hello");}  
}  
class B{  
void msg(){System.out.println("Welcome");}  
}  
class C extends A,B{//suppose if it were  
   
 Public Static void main(String args[]){  
   C obj=new C();  
   obj.msg();//Now which msg() method would be invoked?  throws c.t error
}  
}  


225

ToCheck::
---------
1.what are the contents inside the jdk and jre folders.
2.program to check::
import java.util.*;
public class MyClass {
    static int n1=0,n2=1,n3=1;
    public static void main(String args[]) {
      System.out.println("Enter the fibo number:");
      Scanner scr=new Scanner(System.in);
      int number=scr.nextInt();
      System.out.println(n1+"\n"+n2);
      fibo(number-2);
    }
    public static void fibo(int count){
        while(count>0){
            System.out.println("Iteration number:"+count);
            n3=n1+n2;
            System.out.println(n3);
            n1=n2;
            n2=n3;
           fibo(count-1);
        }
    }
}

