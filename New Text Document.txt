Imp points::
------------
-->In java, a boolean value cannot hold the integer value it holds only true or false.
-->All the objects are stored in the Garbage-collectible heap. so if there are any unreferenced objects those are collected by the garbage collector.
-->if there are 100 classes it is not that easy to deliver all the classes to the client(since misses can happen) so it is quite easy if we package them into a .jar file and specify the manifest file where the main method is.
-->Arrays are always the objects whether they hold the primitive types or reference types.
-->length is just a parameter in the Array.
-------------------------
Disadvantages of Arrays::
-------------------------
1.Arrays cannot grow in size.
2.Arrays are used to store the homogenous types of data.
3.Arrays should always be used by the index.
4.we have to specify the size while creating the array.

we can create the array and initialize in same line using::
String[] arr={"kiran","kumar","seeram"};
or else in seperate lines using::
String[] arr;
arr=new String[]{"kiran","kumar","seeram"};
-------------------
Getters & setters::
-------------------
The getters & setters will not allow the instance variables to be exposed and they provide the validations to the fields before initialization it is a way of achieving encapsulation.
1.All the instance variables are declared private and the getters and setters are provided with public access.
Ex::
-----
public class MyClass {
    public static void main(String args[]) {
       Student stu=new Student();
       stu.setsid(100);
       System.out.println(stu.getSid());
    }
}
class Student{
    int sid;
    //getter
    public int getSid(){
        return this.sid;
    }
    //setter
    public void setsid(int id){
        this.sid=id;
    }
}
-->The instance variables are need not be intitialized even though without initialization they have the default values::
int - 0
float - 0.0
object(references) & string - null
boolean - false
-----------------------------------------------------------
Difference between local variables and instance variables::
-----------------------------------------------------------
Local variables::
-----------------
These are declared inside the method.
instance variables::
--------------------
These are declared inside the class.
1.The instance variables can have the default values where as for the local variables they need to be initialized before the usage.
== Operator::
-------------
the "==" operator is used to check whether two variables values are same or not and it is also used to check whether two reference variables are pointing to the same object or not. In order to compare the objects itself use the equals() method.

-->The "Math" class is present in java.lang package. it also contains objects for Integer,Double,Float
-->The ArrayList class present in the java.util package.
-->the println statement(System.out.println()) is used from java.lang package under system class.
-->The java.lang package is pre-imported into the program by default so that's why when we write System.out.println or Integer we shouldn't import these packages as these are already imported from java.lang package.

ArrayLists::
------------
1.While creation of ArrayList we need not specify any size.

ArrayList<String> arr=new ArrayList<String>();
ArrayList can grow or sink in size.

2.unlike in array's we don't use [] to get the element.
3.ArrayList accepts only Reference types and wrapping or unwrapping is automatically done by the compiler itself.
ArrayList<Integer> arr=new ArrayList<Integer>();

-->In java it is always pass by value only.

Inheritance::
-------------
-->A base class is called superclass and the class which is inheriting that is called subclass.
-->A subclass can inherit all the methods and instance variables from the super class.
-->If a subclass has its own functionality then it can override the base class methods.(the instance variables of the super class are cannot be overridden).
-->In an inheritance structure "the lowest one wins".
Ex:Consider the inheritance structure::(Wolf->Canine->Animal)=>first it will check for the methods in the wolf if it is not there then it will check in the Canine or else it will call the method from Animal.
1.IS-A vs HAS-A relationship::
------------------------------
IS-A ex::(Surgeon extends Doctor) is a specialized component of Doctor.
HAS-A ex::classes (Tub,Sink) the Bathroom class has (Tub,Sink) i.e., the class Bathroom has components of both Tub and Sink.
class Bathroom{
Tub tub;
Sink sink;
}
-->To know if you've designed your types correctly, ask "Does it make sense to say type X is-a type Y".
-->Inheritance is an "IS-A" relationship.
-->Triangle is a shape but the reverse (shape is a Triangle is not true) so inheritance always allows in only one direction.
-->if X IS-A Y (x->y) then X can do all the things that Y can do.

2.common scenarios::
--------------------
a.what if the superclass wants to invoke the methods from subclass??
-->the parent class cannot know about any of the child classes,but during the creation of the child class it must know the which parent class it is inheriting.so , the parent class cannot inherit from child.

b.what if the subclass want to invoke bothe superclass version and its own version of the methods?? 
-->you can invoke the super class method by super.method()

-->The parent class may decide which fields or methods that a child class can inherit by providing the Access levels::
public,private,protected,default
-->we can override the parent class methods in the child class by mentioning the parameter called::@Override

Polymorphism::
--------------
while creating the object, the object type and the reference type are same::
Dog myDog=new Dog();
but in polymorphims the object type and the reference type may not be same::
Animal myDog=new Dog();
so, in an inheritance relationship(IS-A), we can always reference the superclass type. 

Rules for overriding::
----------------------
1.The method which is going to override must contain the same signature and same arguments.
2.the overrided method should not be less accessible.

Rules for Overloading::
-----------------------
-->Overloading is such that with same name we can define multiple functions:
1.In java, method overloading is not possible by changing the return type of the method only because of ambiguity.

Object::
--------
Each and every class implicitly extends the Object functionality::
it has 4 methods::
1.boolean equals()
2.Class getClass() //it is a final method hence cannot be overrided.
3.int hashCode()
4.String toString()

a.different ways to create the object::
-------------------------------------
By new keyword
By newInstance() method
By clone() method
By deserialization
By factory method etc.

b.ways to initialize object::
-----------------------------
By reference variable
By method
By constructor

c.Anonymous objects::
---------------------
new Calculation().fact(5) //suitable only in the driver program only one instance is needed if there is more than one instance it will not be easy to call the object by reference variable.

d.Creating multiple objects by one type only::
----------------------------------------------
Rectangle r1=new Rectangle(), r2=new Rectangle();//creating two objects  
int a=10, b=20;  



225