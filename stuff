java exception handling::
------------------------
exception::
An exception is an abnormal termination from the normal flow of the program.

ex::
suppose if a database is there, and if a connection is made to read the data and in between there is a SQLException and if there is no close of the sql connection this will make the resource consumption and if the database could not handle more than 10 users the 11th user may not connect with the db.

try
{
//open conn
//read data
}
catch(Exception ex)
{
//abnormal execution
}
finally
{
//close the connn
}

-->For every thread jvm internally maintains the "Runtime Stack" for that particular thread.

class Test{
p.s.v.m(){
do stuff();
}
public void dostuff()
{
do morestuff();
}
public void domorestuff()
{
sysout("hello");
}
}
//stack is mentioned as::
domorestuff()
dostuff()
main

If an exception occurs::
public void domorestuff()
{
sysout(10/0)
}
//stack is mentioned as::
domorestuff()
dostuff()
main

//since exception arises at:
domorestuff, JVM will remove that particular line from runtime stack and will not execute the rest of the lines and it will pass to the do stuff method and this cycle repeats....

-->Throwable is root class for all the exceptions and it is extended by the "Exception" and "Error"

Exception::
-----------
all the exceptions are recoverable and these are mainly because of the user program.
try
{
//read from a file located at the london
}
catch(Exception ex)
{
//read from local back up file
}
ex::IOException,RunTimeException

Error::
--------
most of the times errors are not caused by the programs.these can be due to lack of system resources and these are non recoverable.
Ex::OutOfMemoryError,StackOverflowError

The exceptions are broadly classified into 2 types::
a.Checked Exception
While writing the code there might be a chance of leading to the exceptions this is called the Checked Exception.
All the exceptions except Runtime exception,Error are Checked Exception
ex::IOException,SQLException,ClassNotFoundException
ex:: During writing to a file there may be a chance of file doesn't exists,so how you are going to handle this kind of scenarios will be the CheckedException.
-->The classes that extend from Throwable class except RuntimeException and Error are Checked Exceptions.

b.unchecked exception
the exceptions which occur at run time is called as unchecked exceptions.
ex::ArithmeticException

we can provide the exception messages in three methods.
e.printStackTrace // prints exception type,description and where the error occurs
println(e) or println(e.toString()) // prints exception type,description
println(e.getMessage()) //description.

The risky code should be enclosed in try block and the exception itself should be caught in the catch block.
whenever a exception is caught the rest of the lines in the try block are skipped and the control will immediately flow to the catch block.
so,if you contain the code like following::
try
{
//code of 1000 loc
}
catch(Exception ex)
{
//handler code
}
-->If an exception occurs in the first line itself then then the control will be immediately thrown to the catch block and the rest of the 999 loc are not at all executed. so instead of maintaining all of the loc in try block identify which all parts of the code is risky and keep those blocks in the multiple try and catch blocks.
The exceptions may also arise in the catch and finally block also.

consider the following code::
try
{
stmt1
stmt2
stmt3
}
catch(Exception e)
{
stmt4;
}
stmt5

cases::
1.no exception in try block occured::1,2,3,5 normal termination
2.exception occured at stmt2::1,4,5 normal termination
3.exception occured at stmt4:: abnormal termination
4.exception occured at stmt5:: abnormal termination

-->The parent exception should not be the top most exception in the catch block
consider the following code::
try
{
//code
}
catch(Exception ex)
{
//handler
}
catch(ArithmeticException ex)
{
//handler
}

C.T Error:: exception already caught using the exception catch

so,the code should be ::
try
{
//code
}
catch(ArithmeticException ex)
{
//handler
}
catch(SQLException ex)
{
//handler
}
catch(Exception ex)
{
//handler
}

-->Whenever an exception occurs and there is no suitable catch block available for that particular block then that particular exception is carried forward to the jvm where it provides the DefaultExceptionHandler and uses the printStackTrace Method by default to print the error message and the program terminates abnormally.


try can be followed by the catch or finally.
finally is used to write the clean up code.
-->The finally block is guaranteed to execute whether there is an exception or not.
whenever, we write a try block it should be followed by the catch or finally block.

diff b/w finally and finalize is that finally is used to clean up the code written in try block where as finalize is used to cleanup the object level code before it is being killed up by the Garbage collector.

code possiblity::
try
{
//code
}
finally
{
//finally code
}

why finally is allowed after try without catch??
it allows the program with the abnormal termination but before that it may want to perform some of the clean up activities.

partially checked exceptions::
the partially checked exceptions contains both checked as well as unchecked exceptions there are only 2 types of this.
1.Throwable
2.Exception

throw keyword::
sometimes we can create exception object explicitly and can handover the exception to the jvm.
//code..

class Test{
p.s.v.m(String[] args)
{
throw new ArithmeticException("/ by 0"); //creating the exception manually and passing it to the jvm.
}
}

-->Throw will be useful in throwing the user defined exceptions.
-->Throw will be used to throw both the Checked as well as unchecked exceptions.

-->Throw will not be used to throw an class object.






code::
class Test{
p.s.v.m(String[] args)
{
throw new B();
}
}

class B
{

}

ex1::
class Test{
static ArithmeticException ex=new ArithmeticException();
p.s.v.main(String[] args)
{
throw ex;
}
}
//throws Arithmetic Exception.

ex2::
class Test{
ArithmeticException ex;
p.s.v.main(String[] args)
{
throw new ex;
}
}
//throws NullPointer Exception.

ex3::
class Test{
p.s.v.main(String[] args)
{
throw new Exception("exception");
s.o.p("hello"); //C.T error unreachable code
}
}

//In the above when the throw statement was encountered it will throw to the corresponding method catch method if exists, if it doesn't exists then it will by default thrown to the Jvm and the rest of the code is unreachable.

throws keyword::
If in a program, if there is a possibility of CheckedException it is compulsory to handle the checked exception otherwise, we will get compile time error saying ,ex:: unreported error xxxx, must be caught or declared to be thrown.

//It is mainly used to replace the try,catch functionality.

ex1::
import java.io.*;
public class MyClass {
    public static void main(String args[]) {
       
        PrintWriter pw=new PrintWriter("abc.txt"); //C.T error
        pw.println("hello");
       
    }
}

//here it may throw C.T error because there may be a possibility of FileNotFound Exception.

ex2::
public class MyClass {
    public static void main(String args[]) {
       Thread.sleep(10000);//C.T error
      }
      }
//here it will throw C.T. error because there may be a possiblity of Interrupted exceptions(Other threads are calling the main method which is in sleep state)

-->These checked exceptions are handled in 2 ways
1.try,catch
2.throws
we can use throws keyword to delegate the responsibility of exception handling to the caller(JVM,another method), then the caller method is responsible to handle that exception.

ex::
public class MyClass {
    public static void main(String args[]) throws InterruptedException{
       Thread.sleep(10000);
      }
      }

-->throws keyword doesn't prevent abnormal termination of the program.

class Test{
p.s.v.m(String[] args)
{
dostuff();
}
public void dostuff()
{
domorestuff();
}
public void domorestuff()
{
Thread.sleep(1000)// throws c.T error throws InterupptedException must be thrown or caught
}
}

1.here domorestuff() has 2 options either it has to throw that or it must be caught using try or catch letus assume that it throws IE as the domorestuff() is called by dostuff() it will delegate the exception call to the dostuff(),since it(dostuff) doesn't have any exception handling this cycle will be repeated.

ex::

class Test{
p.s.v.m(String[] args) throws InterruptedException
{
dostuff();
}
public void dostuff()
{
domorestuff();
}
public void domorestuff()
{
Thread.sleep(1000)// throws C.T error throws InterupptedException must be thrown or caught
}
}

//here only the main method is throwing the interrupted exception but it doesn't delegated by the domorestuff() method hence it will throw C.T.Error

ex::
class Test{
p.s.v.m(String[] args)
{
throw new Exception(); //c.t error since the checked exceptions need to be handled
}
}

//within the try block if there is no chance of raising an exception, then we can't write catch block for that exception otherwise we will get c.t.error saying, exception xxx is never thrown in body of corresponding try statement,but this rule is fully applicable to the fullyChecked exceptions.

ex::
import java.io.*;
public class MyClass {
    public static void main(String args[]) throws ArithmeticException {
     try
     {
         System.out.println("hello");
     }
     catch(IOException ex){
         System.out.println(ex);
     }
    }
}


customized or user defined exceptions::
programmer defined exceptions are called as customized exceptions.

//throw keyword is best suitable for userdefined or customized exceptions but not for predefined exceptions.

//it is highly recommended to define the customized exceptions as unchecked that is we have to extends runtime exception but not exception.

class CustomException extends RunTimeException{
CustomException(String s)
{
super(s); // super is used because it is used to print the statement to the console to print that the printstacktrace() is used since it //is available in Throwable class we need to use the super keyword
}
}



db::
----
use of initializing the instance variables in the class?
why cant we throw partially checked exceptions using throw?

explore::

import java.io.*;
public class MyClass {
    public static void main(String[] args) throws Throwable
    {
           dostuff();
          
    }
    public static void dostuff(){
        throw new ArithmeticException("test");
    }
}


