java exception handling::
------------------------
exception::
An exception is an abnormal termination from the normal flow of the program.

ex::
suppose if a database is there, and if a connection is made to read the data and in between there is and SQLException and there is no close of the sql connection this will make the resource consumption and if the database could not handle more than 10 users the 11th user may not connect with the db.

try
{
//open conn
//read data
}
catch(Exception ex)
{
//abnormal execution
}
finally
{
//close the connn
}

-->For every thread jvm internally maintains the "Runtime Stack" for that particular thread.

class Test{
p.s.v.m(){
do stuff();
}
public void dostuff()
{
do morestuff();
}
public void domorestuff()
{
sysout("hello");
}
}
//stack is mentioned as::
domorestuff()
dostuff()
main

If an exception occurs::
public void domorestuff()
{
sysout(10/0)
}
//stack is mentioned as::
domorestuff()
dostuff()
main

//since exception arises at:
domorestuff it will not remove that particular line from runtime stack and will not execute the rest of the lines and it will pass to the do stuff method and this cycle repeats....

-->Throwable is root class for all the exceptions and it is implemented by the "Exception" and "Error"

Exception::
-----------
all the exceptions are recoverable and these are mainly because of the user program.
try
{
//read from a file located at the london
}
catch(Exception ex)
{
//read from local back up file
}
ex::IOException,RunTimeException

Error::
--------
most of the times errors are not caused by the programs.these can be due to lack of system resources and these are non recoverable.
Ex::OutOfMemoryError,StackOverflowError

The exceptions are broadly classified into 2 types::
a.Checked Exception
While writing the code there might be a chance of leading to the exceptions this is called the Checked Exception.
All the exceptions except Runtime exception,Error are Checked Exception
ex::IOException,SQLException,ClassNotFoundException
ex:: During writing to a file there may be a chance of file doesn't exists,so how you are going to handle this kind of scenarios will be the CheckedException.
b.unchecked exception
the exceptions which occur at run time is called as unchecked exceptions.
ex::ArithmeticException

we can provide the exception messages in three methods.
e.printStackTrace // prints exception type,description and where the error occurs
println(e) or println(e.toString()) // prints exception type,description
println(e.getMessage()) //description.

The risky code should be enclosed in try block and the exception itself should be caught in the catch block.
whenever a exception is caught the rest of the lines in the try block are skipped and the control will immediately flow to the catch block.
so,if you contain the code like following::
try
{
//code of 1000 loc
}
catch(Exception ex)
{
//handler code
}
-->If an exception occurs in the first line itself then then the control will be immediately thrown to the catch block and the rest of the 999 loc are not at all executed. so instead of maintaining all of the loc in try block identify which all parts of the code is risky and keep those blocks in the multiple try and catch blocks.
The exceptions may also arise in the catch and finally block also.

consider the following code::
try
{
stmt1
stmt2
stmt3
}
catch(Exception e)
{
stmt4;
}
stmt5

cases::
1.no exception occured::1,2,3,5 normal termination
2.exception occured at stmt2::1,4,5 normal termination
3.exception occured at stmt4:: abnormal termination
4.exception occured at stmt5:: abnormal termination

-->The parent exception should be the top most exception in the catch block
consider the following code::
try
{
//code
}
catch(Exception ex)
{
//handler
}
catch(ArithmeticException ex)
{
//handler
}

C.T Error:: exception already caught using the exception catch

so,the code should be ::
try
{
//code
}
catch(ArithmeticException ex)
{
//handler
}
catch(SQLException ex)
{
//handler
}
catch(Exception ex)
{
//handler
}

-->Whenever an exception occurs and there is no suitable catch block available for that particular block then that particular exception is carried forward to the jvm where it provides the DefaultExceptionHandler and uses the printStackTrace Method to print the error message and the program terminates abnormally.


try can be followed by the catch or finally.
finally is used to write the clean up code.
whenever, we write a try block it should be followed by the catch or finally block.

diff b/w finally and finalize is that finally is used to clean up the code written in try block where as finalize is used to cleanup the object level code before it is being killed up by the Garbage collector.

code possiblity::
try
{
//code
}
finally
{
//finally code
}

why finally is allowed after try without catch??
it allows the program with the abnormal termination but before that it may want to perform some of the clean up activities.






